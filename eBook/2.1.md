# 2.1 声明和初始化

当我们第一次看见变量和声明时，我们仅仅看见一些内置的类型，比如整型和字符串。现在我们将学习结构体，并且我们会深入学习包括指针的内容。

通过一种最简单的方式去创建一个结构体值类型：

```go
goku := Saiyan{
    Name: "Goku",
    Power: 9000,
}
```

**注意**：上面的结构体中，结尾的逗号`,`是不能省的。如果没有逗号，编译器会给出一个错误。你将喜欢上这种一致性要求，特别是如果你已经使用一种相反的语言或格式。

我们不需要给结构体设置任何值甚至任何字段。这2中方式都是有效的：

```go
goku := Saiyan{}

// or

goku := Saiyan{Name: "Goku"}
goku.Power = 9000
```

这就像一个未赋值的变量一样，结构体的字段也会有一个0值。

另外，你也可以省略字段的名字，按字段的顺序进行声明（尽管为了简洁起见，你尽量在结构体只有少量字段时才使用这种方式）：

`goku := Saiyan{"Goku", 9000}`

上面的例子主要是声明了一个变量`goku`，并给它赋值。

尽管在大多数时候，我们不希望一个变量直接关联一个值，而是希望一个指针指向变量的值。指针是一个内存地址。通过指针可以找到这个变量实际的值。这是一种间接的取值。严格地说，这与存在一个房子并指向另外一个房子有一些区别。

为什么我们需要一个指针指向一个值，而不需要一个实际值。这主要是因为在go语言中，函数的参数传递都是按值传递，即传递的是一个拷贝。了解到这点，下面程序会打印什么？

```go
func main() {
    goku := Saiyan{"Goku", 9000}
    Super(goku)
    fmt.Println(goku.Power)
}

func Super(s Saiyan) {
    s.Power += 10000
}
```

答案是9000，不是19000。为什么？因为`Super`只是改变了`goku`的一个拷贝，所以在`Super`中的改变不会调用者中反应出来。如果你希望答案是19000，我们需要传递一个指向我们值的指针：

```go
func main() {
    goku := &Saiyan{"Goku", 9000}
    Super(goku)
    fmt.Println(goku.Power)
}
func Super(s *Saiyan) {
    s.Power += 10000
}
```

我们改变了2个地方。首先是使用了`&`操作符去获得我们值的地址（`&`叫取地址符）。接下来，我们改变了`Super`接受的参数类型。之前我们是传递一个`Saiyan`的值类型，现在我们传递了一个地址类型`*Saiyan`，这里的`*X`表示一个指向类型`X`的一个指针。显而易见，`Saiyan`和`*Saiyan`类型之间有一定的联系，但是它们是两种不同的类型。



## 链接

- [目录](directory.md)
- 上一章：[结构体](2.0.md)
- 下一节：[方法](2.2.md)
